-- Client-Side Music Visualizer with AudioAnalyzer (Real FFT)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local MusicVisEvent = ReplicatedStorage:WaitForChild("MusicVisEvent")

-- Store analyzers to prevent recreation
local soundAnalyzers = {}

-- Create AudioAnalyzer for real frequency analysis
local function setupAudioAnalyzer(sound)
	-- Check if we already have an analyzer for this sound
	if soundAnalyzers[sound] then
		local analyzer = soundAnalyzers[sound]
		if analyzer and analyzer.Parent then
			analyzer.SpectrumEnabled = true
			return analyzer
		end
	end
	
	-- Check if AudioAnalyzer already exists in sound
	local analyzer = sound:FindFirstChild("AudioAnalyzer")
	if not analyzer then
		analyzer = Instance.new("AudioAnalyzer")
		analyzer.Name = "AudioAnalyzer"
		analyzer.Parent = sound
		analyzer.SpectrumEnabled = true
		
		-- Create Wire to connect Sound to AudioAnalyzer
		local wire = sound:FindFirstChild("AnalyzerWire")
		if not wire then
			wire = Instance.new("Wire")
			wire.Name = "AnalyzerWire"
			wire.SourceInstance = sound
			wire.TargetInstance = analyzer
			wire.TargetName = "Input"
			wire.Parent = sound
		end
		
		print("[MusicVis] Created AudioAnalyzer and Wire for sound:", sound.Name)
	else
		analyzer.SpectrumEnabled = true
		-- Check if wire exists
		local wire = sound:FindFirstChild("AnalyzerWire")
		if not wire then
			wire = Instance.new("Wire")
			wire.Name = "AnalyzerWire"
			wire.SourceInstance = sound
			wire.TargetInstance = analyzer
			wire.TargetName = "Input"
			wire.Parent = sound
		end
	end
	
	soundAnalyzers[sound] = analyzer
	return analyzer
end

-- Find all sounds in the workspace and character
local function getAllSounds()
	local sounds = {}
	
	-- Get sounds from character
	for _, obj in ipairs(char:GetDescendants()) do
		if obj:IsA("Sound") and obj.IsPlaying then
			table.insert(sounds, {sound = obj, position = hrp.Position})
		end
	end
	
	-- Get sounds from workspace
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Sound") and obj.IsPlaying then
			-- Only include sounds within reasonable distance
			local soundParent = obj.Parent
			if soundParent and soundParent:IsA("BasePart") then
				local distance = (soundParent.Position - hrp.Position).Magnitude
				if distance < 100 then
					table.insert(sounds, {sound = obj, position = soundParent.Position})
				end
			else
				table.insert(sounds, {sound = obj, position = hrp.Position})
			end
		end
	end
	
	return sounds
end

-- Calculate stereo panning based on sound position relative to player
local function getStereoInfo(soundPosition)
	local relativePos = hrp.CFrame:PointToObjectSpace(soundPosition)
	
	-- X is left/right (-X is left, +X is right)
	-- Z is front/back (-Z is front, +Z is back)
	
	local leftRightBalance = math.clamp(relativePos.X / 20, -1, 1) -- -1 = left, 1 = right, 0 = center
	local frontBackBalance = math.clamp(-relativePos.Z / 20, -1, 1) -- 1 = front, -1 = back
	
	return leftRightBalance, frontBackBalance
end

-- Apply stereo effect to frequency bands
local function applyStereoEffect(bands, leftRightBalance, frontBackBalance)
	local stereoBands = {}
	local numBands = #bands
	
	for i = 1, numBands do
		local normalizedPos = (i - 1) / (numBands - 1) -- 0 to 1 (left to right)
		local barPosition = (normalizedPos * 2) - 1 -- -1 to 1 (left to right)
		
		-- Calculate how much this bar should respond based on stereo position
		local stereoInfluence
		if leftRightBalance < 0 then
			-- Sound is on the left, boost left bars
			stereoInfluence = 1 - math.abs(barPosition - leftRightBalance) * 0.7
		elseif leftRightBalance > 0 then
			-- Sound is on the right, boost right bars
			stereoInfluence = 1 - math.abs(barPosition - leftRightBalance) * 0.7
		else
			-- Sound is centered
			stereoInfluence = 1
		end
		
		-- Front/back influence (frontal sounds are fuller)
		local depthInfluence = 0.5 + (frontBackBalance * 0.5)
		
		-- Apply stereo effect with higher max to allow bars to go higher
		stereoBands[i] = bands[i] * stereoInfluence * depthInfluence * 1.8 -- Increased multiplier
	end
	
	return stereoBands
end

-- Smooth interpolation between values
local function smoothInterpolate(bands)
	local smoothed = {}
	for i = 1, #bands do
		if i == 1 then
			smoothed[i] = (bands[i] + bands[i + 1]) / 2
		elseif i == #bands then
			smoothed[i] = (bands[i - 1] + bands[i]) / 2
		else
			-- Average with neighbors for smooth distribution
			smoothed[i] = (bands[i - 1] * 0.25 + bands[i] * 0.5 + bands[i + 1] * 0.25)
		end
	end
	return smoothed
end

-- Create distribution curve effect (like normal/skewed distribution)
local function applyDistributionCurve(bands, centerPeak)
	local numBands = #bands
	local center = centerPeak or (numBands / 2)
	local curved = {}
	
	for i = 1, numBands do
		-- Distance from center (normalized)
		local distFromCenter = math.abs(i - center) / (numBands / 2)
		
		-- Apply gaussian-like curve
		local curveFactor = math.exp(-distFromCenter * distFromCenter * 2)
		
		-- Combine original intensity with curve
		curved[i] = bands[i] * (0.4 + curveFactor * 0.6)
	end
	
	return curved
end

-- Get real frequency bands using AudioAnalyzer
local function getFrequencyBands(sound)
	local success, analyzer = pcall(setupAudioAnalyzer, sound)
	
	if not success or not analyzer then
		print("[MusicVis] Failed to setup AudioAnalyzer:", analyzer)
		analyzer = nil
	end
	
	local spectrum = nil
	if analyzer then
		local specSuccess, specResult = pcall(function()
			return analyzer:GetSpectrum()
		end)
		if specSuccess then
			spectrum = specResult
		else
			print("[MusicVis] GetSpectrum failed:", specResult)
		end
	end
	
	if not spectrum or #spectrum == 0 then
		-- Fallback: Use PlaybackLoudness with distribution curves
		local loudness = sound.PlaybackLoudness
		local time = sound.TimePosition
		local pitch = sound.Pitch or 1
		
		local bands = {}
		
		-- Create wave-like patterns across all 16 bars with higher intensity
		for i = 1, 16 do
			local normalized = (i - 1) / 15 -- 0 to 1
			
			-- Multiple wave frequencies for richness
			local wave1 = math.sin(time * 2.5 + normalized * math.pi * 2)
			local wave2 = math.cos(time * 4.0 + normalized * math.pi * 3)
			local wave3 = math.sin(time * 6.5 + normalized * math.pi)
			
			-- Combine waves with different weights
			local combined = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2)
			
			-- Add loudness influence with higher multiplier
			local intensity = loudness * (0.5 + math.abs(combined) * 1.2)
			
			table.insert(bands, math.clamp(intensity, 0, 150)) -- Increased max to 150
		end
		
		-- Apply distribution curve for peak in middle
		bands = applyDistributionCurve(bands, 8 + math.sin(time * 0.5) * 3)
		
		-- Smooth the bands
		bands = smoothInterpolate(bands)
		
		return bands
	end
	
	-- AudioAnalyzer is working!
	local rawBands = {}
	local numBands = 16
	local spectrumLength = #spectrum
	
	-- Sample across entire spectrum with logarithmic spacing
	for i = 1, numBands do
		-- Logarithmic distribution (more resolution in bass)
		local logPos = math.pow(i / numBands, 1.5)
		local spectrumIdx = math.floor(logPos * spectrumLength) + 1
		spectrumIdx = math.clamp(spectrumIdx, 1, spectrumLength)
		
		-- Get intensity with some averaging
		local sum = 0
		local count = 0
		local range = math.max(1, math.floor(spectrumLength / (numBands * 2)))
		
		for j = math.max(1, spectrumIdx - range), math.min(spectrumLength, spectrumIdx + range) do
			if spectrum[j] then
				sum = sum + spectrum[j]
				count = count + 1
			end
		end
		
		local avgIntensity = count > 0 and (sum / count) or 0
		
		-- Scale based on position (boost bass and treble differently) with higher values
		local positionScale
		if i <= 6 then
			positionScale = 220 -- Bass boost (increased)
		elseif i >= 11 then
			positionScale = 180 -- Treble boost (increased)
		else
			positionScale = 160 -- Mid range (increased)
		end
		
		table.insert(rawBands, math.clamp(avgIntensity * positionScale, 0, 150)) -- Increased max
	end
	
	-- Apply smooth interpolation
	rawBands = smoothInterpolate(rawBands)
	
	-- Apply distribution curve with dynamic center
	local dominantFreq = 1
	local maxIntensity = 0
	for i, v in ipairs(rawBands) do
		if v > maxIntensity then
			maxIntensity = v
			dominantFreq = i
		end
	end
	
	rawBands = applyDistributionCurve(rawBands, dominantFreq)
	
	return rawBands
end

-- Main update loop
local lastUpdate = 0
local updateRate = 1/30 -- 30 times per second
local lastPrimarySound = nil

RunService.RenderStepped:Connect(function()
	local now = tick()
	if now - lastUpdate < updateRate then return end
	lastUpdate = now
	
	local soundData = getAllSounds()
	
	if #soundData > 0 then
		-- Get the loudest sound
		local primarySoundData = soundData[1]
		local maxLoudness = primarySoundData.sound.PlaybackLoudness or 0
		
		for _, data in ipairs(soundData) do
			local currentLoudness = data.sound.PlaybackLoudness or 0
			if currentLoudness > maxLoudness then
				primarySoundData = data
				maxLoudness = currentLoudness
			end
		end
		
		local primarySound = primarySoundData.sound
		local soundPosition = primarySoundData.position
		
		-- Check if sound changed
		if primarySound ~= lastPrimarySound then
			print("[MusicVis] Primary sound changed to:", primarySound.Name, "SoundId:", primarySound.SoundId)
			lastPrimarySound = primarySound
		end
		
		-- Get REAL frequency bands using AudioAnalyzer with distribution curves
		local frequencyBands = getFrequencyBands(primarySound)
		
		-- Calculate stereo position
		local leftRightBalance, frontBackBalance = getStereoInfo(soundPosition)
		
		-- Apply stereo effect to bands
		frequencyBands = applyStereoEffect(frequencyBands, leftRightBalance, frontBackBalance)
		
		-- Send to server with stereo info
		MusicVisEvent:FireServer(
			primarySound.SoundId,
			maxLoudness,
			hrp.Position,
			frequencyBands,
			leftRightBalance -- Send stereo balance for potential server-side effects
		)
	else
		-- No sound playing, send zeros
		if lastPrimarySound then
			print("[MusicVis] No sounds playing")
			lastPrimarySound = nil
		end
		local emptyBands = {}
		for i = 1, 16 do
			table.insert(emptyBands, 0)
		end
		MusicVisEvent:FireServer("", 0, hrp.Position, emptyBands, 0)
	end
end)
